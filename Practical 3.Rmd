---
title: "Practical 3: Web Traffic"
author: "Colin Steffe, Virany Kho, Jasmine Mawjee, Adela Sahraoui"
date: "11/25/2021"
output: html_document
---

```{r data preparation, echo=F, message=F, warning=F}

library(here)
library(dplyr)
library(tidyverse)
library(ggplot2)
library(fpp3)
library(ggthemes)

# Read in the data
load(file = here::here("traffic.Rdata"))

# Convert into tibble 
pageviews <- as_tibble(pageviews)

# Create new column
type <- c("Elizabeth_II", 
          "United_States",
          "Queen_Victoria",
          "World_War_II",
          "World_War_I",
          "George_VI",
          "United_Kingdom",
          "Princess_Margaret,_Countess_of_Snowdon",
          "Prince_Philip,_Duke_of_Edinburgh",
          "Winston_Churchill",
          "Diana,_Princess_of_Wales",
          "2016_Summer_Olympics")

# Add new column
pageviews <- cbind(pageviews,
                   type)

# Reorder colum
pageviews <- pageviews[, c(804, 1:803)]

# Pivot data frame 
pageviews <- pageviews %>% 
             pivot_longer(!type, 
                          names_to = "date", 
                          values_to = "dailycount")

# Convert column date into date format
pageviews$date <- as.Date(pageviews$date, format = "%Y-%m-%d")

# Convert into tsibble
pageviews_ts <- tsibble(pageviews, 
                        index = date,
                        key = c(type, dailycount)) %>% # since duplicates need to keys         
                arrange(type, date)

# str(pageviews_ts) # to verify the structure of dataframe

```

# Informative Plots

## Time Series

If we see a trend, the time series is not stationary (i.e. does not depend on the time of the observation). 

```{r time series plot, echo=F, message=F, warning=F}

library(plotly)

ts_plot <- pageviews_ts %>%
           ggplot(mapping = aes(x = date, 
                                y = dailycount,
                                colour = factor(type))) +
           geom_line() +
  
           labs(title = "Web Traffic: Daily Count",
                x = "Time of Occurrence [1D]", 
                y = "Daily count",
                fill = type)  #+
  
           #theme_economist_white() # we can change the theme for something cooler ? 

ggplotly(ts_plot) %>% 
  config(displayModeBar = T) # can we add the woom opt on the x axis ? 
  
# NEED IMPROVEMENT UNREADABLE 
  
```

## Seasonal plot

If we see a seasonality, the time series is not stationary (i.e. does not depend on the time of the observation). 

```{r seasonal plot, echo=F, message=F, warning=F}

library(tsibble)

# Fill time gaps
pageviews_nogaps <- pageviews_ts %>%
                    fill_gaps()

```

### Elizabeth_II

Je sais pas pk ca tourne pdt mille ans sans voir le résultat

```{r seasonal Elizabeth_II, echo=F, message=F, warning=F}

library(feasts)

# Seasonal plot
eliz_seasonal <- pageviews_nogaps %>% 
                 filter(type == "Elizabeth_II") %>%
                 gg_season(y = dailycount) 

# Subseries
eliz_sub <- pageviews_nogaps %>% 
            filter(type == "Elizabeth_II") %>%
            gg_subseries(y = dailycount) 



```

- time series decompostion

## Autocorrelation plot

Autocorrelation quantifies the relationship between lagged values of a time series.

# Modified Series

$$
R_i = \frac{X_i - X_{i-7}}{X_{i-7}} * 100
$$
$R_i$ is the modified time series where each series (above $R_8$) of pageviews is the relative percentage change time series between one observation at time $i$ and the seventh before $i-7$ ?

```{r modified time series, echo=F, message=F, warning=F}

# pour chaque "type" on crée une time series modifiée "modified_ts" pour lesquelles on recalcules la valeur de daily count en utilisant la formule du dessus. etant donné qu'on a - Xi-7 on peut que commencer à calculer pour la 8ème observation de chaque time series (1 par type)

type <- as.factor(type)

# Create a modified time series using the initial one
modified_ts <- pageviews_ts
ind <- 1
    
for (i in levels(type)) {
  
  subset_type <- pageviews_ts %>%
                 filter(type == i)
    
  for (j in 1:nrow(subset_type)) {
    
    if (j > 7) {
      
    modified_ts$dailycount[[ind]] <- ((subset_type$dailycount[[j]] -  subset_type$dailycount[[j-7]])/subset_type$dailycount[[j-7]])*100
    
    } else {
      
      modified_ts$dailycount[[ind]] <- NA
      
    }
    
    ind <- ind + 1
  }
}

modified_ts <- rename(modified_ts, 
                      "daily count modified" = "dailycount")

```

```{r modified time series plot, echo=F, message=F, warning=F}

modifiedts_plot <- modified_ts %>%
                   ggplot(mapping = aes(x = date, 
                                        y = `daily count modified`,
                                        colour = factor(type))) +
                   geom_line() +
  
                   labs(title = "Modified Time Series: Web Traffic",
                        x = "Time of Occurrence [1D]", 
                        y = "Modified Daily count",
                        fill = type)  +
          
                   theme_economist_white() # we can change the theme for something cooler ? 

ggplotly(modifiedts_plot) %>% 
  config(displayModeBar = T) # can we add the woom opt on the x axis ? 
  
# NEED IMPROVEMENT UNREADABLE 

```

```{r full data, echo=F, message=F, warning=F}

# Binding the modified daily count to have everything in the same place
ts <- bind_cols(pageviews_ts, modified_ts) 

ts <- inner_join(pageviews_ts, modified_ts, by = c("type","date"))

ts <- ts %>%
      arrange(type, date)

```

## 2016_Summer_Olympics

To compare the time series before and after modification 

```{r relative change 2016_Summer_Olympics, echo=F, message=F, warning=F}



# solution to align the 0 : https://stackoverflow.com/questions/52443673/one-zeroline-for-two-y-axis-in-plotly

tss <- ts %>%
       filter(type == "2016_Summer_Olympics")

yaxis1 <- list(zeroline = TRUE,
               range = c(min(tss$`daily count modified`, na.rm = TRUE),max(tss$`daily count modified`, na.rm = TRUE))
)

yaxis2 <- list(
    tickfont= list(color = "orange"),
    overlaying="y",
    side="right",
    title="daily count",
    zeroline = TRUE,
    range = c(min(tss$`daily count modified`, na.rm = TRUE),max(tss$dailycount, na.rm = TRUE))
)

plot_ly(tss,width = 800, height = 350) %>% 
add_lines(x = ~date, 
          y= ~`daily count modified`, 
          name = "daily count modified") %>%
add_lines(x = ~date, 
          y = ~dailycount, 
          name = "daily count",
          yaxis = "y2") %>%
  layout(title = "daily count for 2016 summery Olympics", yaxis = yaxis1 ,
         yaxis2 = yaxis2) %>% 
  config(displayModeBar = FALSE)






```

# Peaks-Over-Threshold

- Examine the suitability for each time series $R_i$ separately
- Explain your choice of threshold and briefly comment on the diagnostic plots for each model

```{r qqplot, echo=F, message=F, warning=F}

# qqplot by types ( two ways)

types <- unique(ts$type)
 
# one plot per type
for (typex in types){
  
 ts_type <- ts %>% 
   filter(type == typex) 
 
  qqnorm(ts_type$`daily count modified`,
       ylab = "Latitude of Seismic Events",
       col = "purple")
  
  
  ggplot(data = ts_type, aes(sample = `daily count modified`)) + 
  geom_qq(color = "pink") +
  geom_qq_line(color = "dark green") +
  labs(y = "Latitude of Seismic Events") %>% print ()
  
}

```

```{r mean residual plot, echo=F, message=F, warning=F}

types <- unique(ts$type)
 
for (typex in types){
  
 ts_type <- ts %>% 
   filter(type == typex) 
 
 ts_type <- ts_type %>% 
   filter(!is.na(`daily count modified`))
 
  # Mean Residual Life Plot (MRLP)
  extRemes::mrlplot(ts_type$`daily count modified`,
                  main = paste("Mean Residual Life Plot: Mean Excess Function for", typex))
}

```

```{r peak-over-threshold plot, echo=F, warning=F, message=F}

types <- unique(ts$type)

thresholds <- c(60, 70, 125, 200, 100, 700, 100, 50, 35, 100, 25, 30)

i <- 1

for (typex in types){
  
 ts_type <- ts %>% 
   filter(type == typex) 
 
 ts_type <- ts_type %>% 
   filter(!is.na(`daily count modified`))

 plot(x = rep(1:nrow(ts_type), 
                    each = 1), 
            y = unlist(ts_type$`daily count modified`), 
            main = paste("Peak-Over-Threshold plot Exceedances for : ", typex),
            sub = paste("threshold =", thresholds[i]), 
            xlab = "Observations", 
            ylab = "Threshold") 
 
 pot_points <- unlist(ts_type$`daily count modified`) > thresholds[i]

 points(x = rep(1:nrow(ts_type), each = 1)[pot_points], 
       y = unlist(ts_type$`daily count modified`)[pot_points], 
       col = "red")

 
 abline(abline(h = thresholds[i], col = "red"))
 
 i <- i+1
 
}

```
Suitability of POT:
- Princess Margaret, United Kingdom, United States (?), Wiston Churchill do not seem to be suitable for POT because of the too few numbers of exceedances.



- Estimate the 99%-quantile of each series and give a corresponding measure of uncertainty = provide an interval of values within which the true value  of the threshol is believed to lie with a stated probability (MSE ? with confidence interval ?)

```{r}

library(evd)
# data frame for the 99 quantile and measure of uncertainty for all the type

data99 <- data.frame(matrix(0, nrow = 2, ncol = length(unique(ts$type))))
colnames(data99) <- unique(ts$type)


for (i in 1:ncol(data99)){

  # filter for the type
   ts_type <- ts %>% 
   filter(type == names(data99)[i]) 
 
   # remove na
 ts_type <- ts_type %>% 
   filter(!is.na(`daily count modified`))
 
 # compute 99 quantile
 quantile99 <- quantile(ts_type$`daily count modified` , 0.99)
 
 # save the quantile in the data.frame
 data99[1,i] <- quantile99 
 
 # measure of uncertainty
 
 # not sure about the mper argument
 # doc of the function here : https://www.rdocumentation.org/packages/evd/versions/2.3-3/topics/fpot
 uncertainty <- fpot(ts_type$`daily count modified`, threshold = thresholds[i], mper = quantile99)
 
 # not sure if we need to save the r level or shape
 data99[2,i] <- uncertainty$std.err[1]
}


```




# Detecting Simultaneous High Load

- Propose one graphical method
- Propose one numerical method

for detecting simultaneous high load across the 12 series provided, Which pages seem to have simultaneous high load?

```{r}
# voir module 4

library(extRemes)
# idea for graphical representation : block maxima by week colored by type
# https://rdrr.io/cran/extRemes/man/blockmaxxer.html
tsnona <- ts%>% filter(!is.na(`daily count modified`))

# compute block maxima
bm <- blockmaxxer(tsnona, blocks = tsnona$date, which="daily count modified")

# need to to color by variable type
plot(tsnona$date, tsnona$`daily count modified`, xlab = "Year", ylab = "daily count modified",
    cex = 1.25, cex.lab = 1.25,
    col = factor(tsnona$type), bg = "lightblue", pch = 21)
points(bm$date, bm$`daily count modified`, col="darkred", cex=1.5)



# numerical method 
# GDP model ?
#https://rdrr.io/cran/evir/man/gpd.html
library(evir)
modified_NoNA <- modified_ts %>% filter(!is.na(`daily count modified`))

gpd.model <- gpd(modified_NoNA$`daily count modified`, threshold = mean(thresholds), method = "ml")

```

